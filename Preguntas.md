1. **Explicar cuándo empezamos a tener problemas con la coherencia y cuál es el problema de tener incoherentes la memoria con las caches.**
	- Empezamos a tener problemas con la coherencia en el cache cuando estamos en sistemas multiprocesador, en los cuales varios cores pueden estar ejecutando un mismo proceso y usando las mismas variables. Entonces hay que mantener coherentes los caches de ambos cores que estén manejando el proceso, para evitar fallos en la lógica del programa o acceso a datos incorrectos.
	- *El problema también está en E/S con DMA. Sería mejor decir que hay problemas con la coherencia cuando existen varias copias del mismo dato en diferentes niveles de la jerarquía de memoria. Esto ocurre tanto en sistemas multiprocesadores SMP, donde hay caches privadas L1 y L2, en donde puede estar la misma línea en las privadas de un procesador y las tengamos que modificar en otro, necesitamos o desalojarla o actualizarla.*

2. **Explicar las diferentes políticas de escritura, comparándolas según el uso de procesador y el uso del bus. ¿Cuál es más apta para un sistema Monoprocesador y cuál para un sistema SMP? Justificar.**
	- Las políticas que se tienen a la hora de escribir en el cache son dos:
		- **Write Through**: la línea se modifica en el primer nivel y luego se propaga el cambio al nivel inferior de la jerarquía inmediato. Es decir, si actualizamos algo en Cache L1, entonces también se escribe esta línea en L2. Si L2 es también de política Write Through, se escribe luego en L3 y así hasta llegar a la memoria principal.
		- **Write Back**: la línea se escribe en el nivel de la jerarquía correspondiente y se tiene un bit para indicar que la línea está Dirty (modificada). Solo se va a llevar al resto de la jerarquía en caso de que se desaloje la línea.
	- Claramente para un sistema monoprocesador conviene una escritura Write Back. No necesitamos tener el dato replicado a lo largo de la jerarquía de memoria en todo momento, por principio de localidad vamos a seguir accediendo al dato sin desalojarlo de la memoria en el momento cercano.
	- En los multiprocesador también vamos a querer mantener la mayor cantidad de tiempo posible un Write Back, pues es menos costoso en ancho de banda y maximiza la velocidad de escritura. Esto porque saturaría el bus de para actualizar la cache compartida. Además produce menos stalls de espera en escritura, implementando la política junto a un Write Buffer para generar menos Write Stalls.
	- Ahora, es conveniente tener L1 con Write Through hacia L2, y luego L2 y L3 ser Write Back, pues es menos costoso escribir de L1 a L2 que de L1 a Memoria, y mantiene la coherencia entre L1 y L2, *esto simplifica la coherencia entre las caches de los otros cores, solamente teniendo que vigilar el bus saliente de L2*.

3. **¿Qué entiende por snooping y con qué elementos se implementa? ¿Cómo se complementa con el protocolo MESI? ¿Qué cosas se tienen que agregar a nivel de HW para implementar MESI (snoop bus, Shared, RFO)?**
	- Se entiende por snooping al uso de un bus que "espíe" el estado de los demás cores, avisando si poseen o no un address, si se efectuó una lectura sobre el mismo o si fue una escritura, para así poder decidir si un core debe o no efectuar unas acciones o no (como por ejemplo invalidar una línea).
	- Para implementarlo se utiliza un pequeño bus entre el cache L2 (recordando que DL1 y L2 están coherentes por DL1 ser Write Through). Este bus nos dice si la línea está o no en ese cache y luego se reciben las señales de control del Cache Controller.
	- Con MESI se complementa en que, el bus se encarga de enviar señales como si se efectuó un Write Miss sobre un determinado address para algún core, lo que lleva a que los otros deban invalidar las líneas, pues el core que efectuó el Write Miss ahora es dueño exclusivo de esa línea. También se propagan los Read Misses, los cuales permiten que aquellas líneas en estado Exclusive pasen a estado Shared en caso de que esté dentro de su cache.
	- Además se implementan al Snoop Bus dos señales: **Shared** y **RFO**. Shared salta en caso de que al efectuarse un Read Miss, otro cache que recibió el address tenga el tag correspondiente a ese address. De manera tal que avisa al cache que efectuó un Read Miss que esa línea está en otro core, y no ponga su estado como Exclusive, sino como Shared. **RFO**, por su parte indica, cuando se produce un **write miss**, que tenemos el estado Shared y queremos modificarlo. Lo que hace es leer la línea del cache que la tenga o de memoria, y luego enviar un Invalidate a todas aquellas que lo tengan, porque nosotros vamos a ser los dueños de esa línea a partir de ahora.